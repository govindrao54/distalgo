import sys
import random
import time

config(channel is fifo, clock is lamport)

# calling all the request at once for all the processes
# logs available for following two conditions
# when some process releases a CS, 
# ---- case a) 
# --------- then all other processes remove ANY ONE tuple from their respective queue such that the c (the logical clock time passed in the arguments) matches with it
# ---- case b) 
# --------- then all other processes remove ALL tuples from their respective queue such that the c matches

class M(process):
    def setup():  # s is set of all other processes
        self.CRITICAL_BUSY = False
        
    def receive(msg= ('CS_TAKEN', c2, p)):
        # output('handler function receive - CS_TAKEN')
        if CRITICAL_BUSY == True:
            output("SAFETY VIOLATED - ", p)
        else:
            CRITICAL_BUSY = True;

    def receive(msg= ('CS_RELEASED', c2, p)):                                            
        # output('handler function receive - CS_RELEASED')
        CRITICAL_BUSY = False;

    def run():
        await(received(('done',), from_=parent()))
        output('terminating M')


class P(process):
    def setup(s:set, nrequests:int, monitor):  # s is set of all other processes
        self.q = set()
        self.clockList = []
        self.monitor = monitor

    def task(c):
        # output('helper function - task')
        -- critical_section
        send(('CS_TAKEN', logical_clock(), self), to= monitor)
        output('in cs', self)


    def requestCS(c):
        # output('helper function - requestCS')
        -- request
        send(('request', c, self), to= s)
        q.add(('request', c, self))


    def releaseCS(c):
        # output('helper function - releaseCS')
        -- release
        q.remove(('request', c, self))
        send(('release', logical_clock(), self), to= s)   


    def receive(msg= ('request', c2, p)):
        output('handler function receive - request', p)

        q.add(('request', c2, p))
        send(('ack', logical_clock(), self), to= p)


    # some process pk released critical section
    def receive(msg= ('release', _, p)):
        output('handler function receive - release', p)
        send(('CS_RELEASED', logical_clock(), self), to= monitor)
        # so what every process does is, it checks for the all the tuples with same logical time
        for x in setof(('request', c, p), ('request', c, _p) in q):
            q.remove(x)
            # break


    def run():
        # output('helper function - run')

        for i in range(nrequests):
            c = logical_clock()
            # output('for loop request number - ', i, 'logical_clock - ', c)
            self.clockList.append(c)
            requestCS(c)

        for elem in self.clockList:
            await(
                # tuple is either self or the one with smallest timestamp
                each(('request', c2, p) in q, has= (c2, p)==(elem, self) or (elem, self) < (c2, p)) 
                and 
                # each process has sent ack to p and timestamp of ack are more than the req timestamp
                each(p in s, has= some(received(('ack', c2, _p)), has= c2 > elem))
                )
            # Lamport Condition 05 met, give access to critical section
            task(elem)
            releaseCS(elem)

        send(('done', self), to= parent())
        await(received(('done',), from_=parent()))
        output('terminating P')

def main():
    output('main function - *************** << python -m da main.da p r n d a part >> *****************')
    # Your main program must be named
    # "main.da", and must run with a command like the following, where 
    # "p" is for number of processes, 
    # "r" is for total number of requests, 
    # "n" is for number of runs for correctness testing, and 
    # "d" and "a" are for number of parameter values and number of repetitions, respectively, for performance testing:
    # python.exe -m da main.da p r n d a

    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrequests = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    nn = int(sys.argv[3]) if len(sys.argv) > 3 else 1
    nd = int(sys.argv[4]) if len(sys.argv) > 4 else 1
    na = int(sys.argv[5]) if len(sys.argv) > 5 else 1
    part = int(sys.argv[6]) if len(sys.argv) > 6 else 1

    spacing = int(nrequests / nd )

    output('PART SELECTED - ', part)
    

    if part == 1:
    
        # selecting random number of requests
        curr_nrequests = random.randint(1,nrequests)
        # selecting random number of processes
        curr_nprocs = random.randint(1,nprocs)

        output('number of processes - ', curr_nprocs, 'number of requests - ', curr_nrequests)
        
        # loop for correctness testing
        for k in range(1,nn+1):
            output('CORRECTNESS TESTING COUNT - ', k, 'of', nn, 'CCCCCCCCCCCCCCCCCCCCCCCCCCCC')

            # start monitor process
            m = new(M)
            for p2 in m: setup(m, ())
            start(m)

            # setup individual processes
            ps = new(P, num=curr_nprocs)
            for p in ps: setup(p, (ps-{p}, curr_nprocs, m))
            # start process ps
            start(ps)
            
            # wait for sometime else just go to next iteration
            if await(each(p in ps, has=received(('done', p)))):
                output('CORRECTNESS RESULT - NO DEADLOCK')
                time.sleep(2)
            elif timeout(1):
                output('CORRECTNESS RESULT - DEADLOCK OCCURRED!')

            output('\n\n\n\n\n\n')
            # terminate process ps
            send(('done',), to=ps)
            send(('done',), to=m)


    elif part == 2:

        # loop for fixed repetitions
        for l in range(1,na+1):
            output('REPETITION NO - ', l, 'of',na, 'RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR')
            # loop for even spacing
            for i in [j for j in range(1, nrequests+1) if j % spacing == 0]:
                output('REQUEST COUNT - ', i, ' total - ', nrequests)

                # loop for correctness testing
                for k in range(1,nn+1):
                    output('CORRECTNESS TESTING COUNT - ', k, 'of', nn, 'CCCCCCCCCCCCCCCCCCCCCCCCCCCC')
                    output('number of processes - ', nprocs, 'number of requests - ', i)

                    # start monitor process
                    m = new(M)
                    for p2 in m: setup(m, ())
                    start(m)

                    # setup individual processes
                    ps = new(P, num=i)
                    for p in ps: setup(p, (ps-{p}, i, m))
                    # start process ps
                    start(ps)
                    
                    # wait for sometime else just go to next iteration
                    if await(each(p in ps, has=received(('done', p)))):
                        output('CORRECTNESS RESULT - NO DEADLOCK')
                        time.sleep(2)
                    elif timeout(2):
                        output('CORRECTNESS RESULT - DEADLOCK OCCURRED, LIVENESS VIOLATED')

                    output('\n\n\n\n\n\n')
                    # terminate process ps
                    send(('done',), to=ps)
                    send(('done',), to=m)

    output('The End')
    # main process terminates
