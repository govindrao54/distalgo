import sys
config(channel is fifo, clock is lamport)

# calling all the request at once for all the processes
# logs available for following two conditions
# when some process releases a CS, 
# ---- case a) 
# --------- then all other processes remove ANY ONE tuple from their respective queue such that the c (the logical clock time passed in the arguments) matches with it
# ---- case b) 
# --------- then all other processes remove ALL tuples from their respective queue such that the c matches

class P(process):
    def setup(s:set, nrequests:int):  # s is set of all other processes
        self.q = set()
        self.clockList = []

    def task(c):
        output('helper function - task *** corresponding to logical_clock -', c)
        -- critical_section
        output('in cs')


    def requestCS(c):
        output('helper function - requestCS')

        -- request
        send(('request', c, self), to= s)
        q.add(('request', c, self))


    def releaseCS(c):
        output('helper function - releaseCS')

        -- release
        q.remove(('request', c, self))
        send(('release', logical_clock(), self), to= s)   


    def receive(msg= ('request', c2, p)):
        output('handler function receive - request')

        q.add(('request', c2, p))
        send(('ack', logical_clock(), self), to= p)


    # some process pk released critical section
    def receive(msg= ('release', _, p)):
        output('handler function receive - release')
        # so what every process does is, it checks for the all the tuples with same logical time
        for x in setof(('request', c, p), ('request', c, _p) in q):
            q.remove(x)
            break


    def run():
        output('helper function - run')

        for i in range(nrequests):
            c = logical_clock()
            output('for loop request number - ', i, 'logical_clock - ', c)
            self.clockList.append(c)
            requestCS(c)

        for elem in self.clockList:
            await(
                # tuple is either self or the one with smallest timestamp
                each(('request', c2, p) in q, has= (c2, p)==(elem, self) or (elem, self) < (c2, p)) 
                and 
                # each process has sent ack to p and timestamp of ack are more than the req timestamp
                each(p in s, has= some(received(('ack', c2, _p)), has= c2 > elem))
                )
            # Lamport Condition 05 met, give access to critical section
            task(elem)
            releaseCS(elem)

        send(('done', self), to= parent())
        await(received(('done',), from_=parent()))
        output('terminating')

def main():
    output('main function - *****************************************************************')

    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrequests = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    ps = new(P, num=nprocs)
    for p in ps: setup(p, (ps-{p}, nrequests))
    start(ps)
    await(each(p in ps, has=received(('done', p))))
    send(('done',), to=ps)

# This is an executable specification of the algorithm described in
# Lamport, L. (1978). "Time, clocks, and the ordering of events in a
# distributed system".  Communications of the ACM, 21(7):558-565.

# This code includes setup and termination for serving a given number of
# requests per process.

# All labels are not needed,
# leaving 14 or 15 lines total for the algorithm body and message handlers.
