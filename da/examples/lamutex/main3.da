import sys
import time
import random
config(channel is fifo, clock is lamport)
# request checkCS, ack checkCS, release checkCS

DELAY = 0

class P(process):
    def setup(s:set, nrequests:int):  # s is set of all other processes
        self.q = set()
        self.req_clk_t = []
        self.acks = []

    def customTask():
        #the task takes randomly 200 ms to 900 ms
        if DELAY == 1:
            t_random = random.randint(200,600)
            time.sleep(t_random / 1000)
        else:
            t_random = 0

        output('helper function - customTask - ', t_random, ' milliseconds')

    def requestCS():
        c = logical_clock()
        output('logical_clock() - ' , logical_clock(), 'helper function - requestCS')
        send(('request', c, self), to= s)
        # save for looping over later
        self.req_clk_t.append(c)

        q.add(('request', c, self))
        checkCS();

    def releaseCS(c):
        output('logical_clock() - ' , logical_clock(), 'helper function - releaseCS')
        #remove from queue
        q.remove(('request', c, self))
        #remove from local variable
        self.req_clk_t.remove(c)

        send(('release', c, self), to= s)
        # checkCS()

    def checkCS():
        # -- critical_section
        output('value of req_clk_t - ', self.req_clk_t)
        output('setof o/p - ', setof((msg, sender), (msg, sender) in received));
        for c in self.req_clk_t:
            output('logical_clock() - ' , logical_clock(), 'helper function - checkCS', self.q)
            if each(('request', c2, p) in q, has= (c2, p)==(c, self) or (c, self) < (c2, p)) and each(p in s, has= some(received(('ack', c2, _p)), has= c2 > c)):
                output('Lamport Condition 05 SUCCESS for - ', self, c)
                customTask()
                releaseCS(c)
                break
            else:
                # output('Lamport Condition 05 FAILED for - ', p)
                await(True)
                output('not waiting for')

    def receive(msg= ('ack', c2, p)):
        output('logical_clock() - ' , logical_clock(), 'ack event handler - called by', p)
        # if all the acks are received, 
        self.acks.append(('ack', c2, p))
        # check if critical section can be allocated, i.e. ack was received by all the process
        checkCS();

    # this is like event handler - for message of the type 'request'
    def receive(msg= ('request', c2, p)):
        output('logical_clock() - ' , logical_clock(), 'request event handler - called by', p)
        q.add(('request', c2, p))
        send(('ack', logical_clock(), self), to= p)
        
        # check if critical section can be allocated
        checkCS();

    # this is like event handler - for message of the type 'release'
    def receive(msg= ('release', _, p)):
        output('logical_clock() - ' , logical_clock(), 'release event handler - called by', p)
        c = logical_clock()
        for x in setof(('request', c, p), ('request', c, _p) in q):
            output('DISCARDING - ', x)
            q.remove(x)
            break
        
        # check if critical section can be allocated
        checkCS();

    def run():
        output('logical_clock() - ' , logical_clock(), 'DELAY is ', 'ON' if DELAY else 'OFF')
        # randomize the sending of request
        for i in range(nrequests):
            # randomly wait for anything between 1 to 5 seconds
            if DELAY == 1:
                t_random = random.randint(1,5)
                output('logical_clock() - ' , logical_clock(), 'sleeping for ', t_random, ' seconds')
                time.sleep(t_random)

            requestCS()

        output('logical_clock() - ' , logical_clock(), 'value of q before exiting - ', q)
        output('value of req_clk_t', self.req_clk_t)

        # finally kill the process
        send(('done', self), to= parent())
        await(received(('done',), from_=parent()))
        output('logical_clock() - ' , logical_clock(), 'terminating')

def main():
    nprocs = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    nrequests = int(sys.argv[2]) if len(sys.argv) > 2 else 1

    ps = new(P, num=nprocs)
    for p in ps: setup(p, (ps-{p}, nrequests))
    start(ps)
    await(each(p in ps, has=received(('done', p))))
    send(('done',), to=ps)


